<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
      <title>GraphQL - Interpreter</title>
    
    <link href="https://fonts.googleapis.com/css?family=Rubik:300,400" rel="stylesheet" />
    <link rel="stylesheet" href="/css/main.css">
    <link rel="icon" href="/graphql-ruby-icon.png">
  </head>
  <body>
    <div class="header">
      <div class="header-container">
        <div class="nav">
          <a href="/" class="img-link">
            <img src="/graphql-ruby.png" alt="GraphQL Ruby Logo" />
          </a>
          <a href="/getting_started">Get Started</a>
          <a href="/guides">Guides</a>
          <a href="/api-doc/1.12.5/">API</a>
          <a href="https://tinyletter.com/graphql-ruby">Newsletter</a>
          <a href="https://github.com/rmosolgo/graphql-ruby">Source Code</a>
          <a href="https://graphql.pro">Upgrade to Pro</a>
          <input
            class="search-input"
            onkeyup="GraphQLRubySearch.run(this)"
            type="text"
            placeholder="Search the docs..."
          />
        </div>
      </div>
      <div class="search-results-container">
        <div id="search-results">
        </div>
      </div>
    </div>
    <div class="container">
      <p class="breadcrumb">
  <a href="/">GraphQL</a>
  &raquo; <a href="/guides">Guides</a>
   &raquo; <a href="/guides#queries-guides">Queries</a>
  &raquo; Interpreter
</p>


<h1 class="guide-header">Interpreter</h1>
<div class="guide-container">
  <p>GraphQL-Ruby 1.9.0 includes a new runtime module which you may use for your schema. It is the default runtime since 1.12.0.</p>

<p>It‚Äôs called <code class="language-plaintext highlighter-rouge">GraphQL::Execution::Interpreter</code>, read on to learn more!</p>

<h2 id="rationale">Rationale</h2>

<p>The new runtime was added to address a few specific concerns:</p>

<ul>
  <li><strong>Validation Performance</strong>: The previous runtime depended on a preparation step (<code class="language-plaintext highlighter-rouge">GraphQL::InternalRepresentation::Rewrite</code>) which could be very slow in some cases. In many cases, the overhead of that step provided no value.</li>
  <li><strong>Runtime Performance</strong>: For very large results, the previous runtime was slow because it allocated a new <code class="language-plaintext highlighter-rouge">ctx</code> object for every field, even very simple fields that didn‚Äôt need any special tracking.</li>
  <li><strong>Extensibility</strong>: Although the GraphQL specification supports custom directives, GraphQL-Ruby didn‚Äôt have a good way to build them.</li>
</ul>

<h2 id="installation">Installation</h2>

<p>In GraphQL-Ruby 1.12, the interpreter is installed <strong>by default</strong>. In older versions, you can opt in to the interpreter in your schema class:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MySchema</span> <span class="o">&lt;</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Schema</span>
  <span class="c1"># These are default in 1.12+:</span>
  <span class="n">use</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Execution</span><span class="o">::</span><span class="no">Interpreter</span>
  <span class="n">use</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Analysis</span><span class="o">::</span><span class="no">AST</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Some Relay configurations must be updated too. For example:</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">- field :node, field: GraphQL::Relay::Node.field
</span><span class="gi">+ add_field(GraphQL::Types::Relay::NodeField)
</span></code></pre></div></div>

<p>(Alternatively, consider implementing <code class="language-plaintext highlighter-rouge">Query.node</code> in your own app, using <code class="language-plaintext highlighter-rouge">NodeField</code> as inspiration.)</p>

<h2 id="compatibility">Compatibility</h2>

<p>The new runtime works with class-based schemas only. Several features are no longer supported:</p>

<ul>
  <li>
    <p>Proc-dependent field features:</p>

    <ul>
      <li>Field Instrumentation</li>
      <li>Middleware</li>
      <li>Resolve procs</li>
      <li><code class="language-plaintext highlighter-rouge">GraphQL::Function</code></li>
    </ul>

    <p>All these depend on the memory- and time-hungry per-field <code class="language-plaintext highlighter-rouge">ctx</code> object. To improve performance, only method-based resolves are supported. If need something from <code class="language-plaintext highlighter-rouge">ctx</code>, you can get it with the <code class="language-plaintext highlighter-rouge">extras: [...]</code> configuration option. To wrap resolve behaviors, try <a href="/type_definitions/field_extensions">Field Extensions</a>, <a href="/queries/tracing">Tracing</a>, or <a href="/fields/resolvers">GraphQL::Schema::Resolver</a>.</p>
  </li>
  <li>
    <p>Query analyzers and <code class="language-plaintext highlighter-rouge">irep_node</code>s</p>

    <p>These depend on the now-removed <code class="language-plaintext highlighter-rouge">Rewrite</code> step, which wasted a lot of time making often-unneeded preparation. Most of the attributes you might need from an <code class="language-plaintext highlighter-rouge">irep_node</code> are available with <code class="language-plaintext highlighter-rouge">extras: [...]</code>. Query analyzers can be refactored to be static checks (custom validation rules) or dynamic checks, made at runtime. The built-in analyzers have been refactored to run as validators.</p>

    <p>For a replacement, check out:</p>

    <ul>
      <li><a href="/api-doc/1.12.5/GraphQL/Execution/Lookahead" target="_blank" title="API docs for GraphQL::Execution::Lookahead"><code>GraphQL::Execution::Lookahead</code></a> for field-level info about child selections</li>
      <li><a href="/api-doc/1.12.5/GraphQL/Analysis/AST" target="_blank" title="API docs for GraphQL::Analysis::AST"><code>GraphQL::Analysis::AST</code></a> for query analysis which is compatible with the new interpreter</li>
    </ul>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">rescue_from</code></p>

    <p>This was built on middleware, which is not supported anymore. For a replacement, see <a href="/errors/error_handling">Error Handling</a>.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">.graphql_definition</code> and <code class="language-plaintext highlighter-rouge">def to_graphql</code></p>

    <p>The interpreter uses class-based schema definitions only, and never converts them to legacy GraphQL definition objects. Any custom definitions to GraphQL objects should be re-implemented on custom base classes.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">GraphQL::Schema::Field#resolve_field</code></p>

    <p>If you customized your base field‚Äôs resolution method, it needs an update. The interpreter calls a different method: <code class="language-plaintext highlighter-rouge">#resolve(obj, args, ctx)</code>. There are two differences with the new method:</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">args</code> is plain ol‚Äô Ruby Hash, with symbol keys, instead of a <code class="language-plaintext highlighter-rouge">GraphQL::Query::Arguments</code></li>
      <li><code class="language-plaintext highlighter-rouge">ctx</code> is a <code class="language-plaintext highlighter-rouge">GraphQL::Query::Context</code> instead of a <code class="language-plaintext highlighter-rouge">GraphQL::Query::Context::FieldResolutionContext</code></li>
    </ul>

    <p>But besides that, it‚Äôs largely the same.</p>
  </li>
</ul>

<p>Maybe this section should have been called <em>incompatibility</em> ü§î.</p>

<h2 id="extending-the-runtime">Extending the Runtime</h2>

<p>See <a href="/type_definitions/directives">Directives</a>.</p>

<h2 id="analyzers">Analyzers</h2>

<p>GraphQL-Ruby has ‚Äúanalyzers‚Äù that run <em>before</em> execution and may reject a query. With the interpreter, you can use <a href="/queries/ast_analysis">AST Analyzers</a> to get better performance.</p>

<p>To make the migration, convert your previous analyzers to extend <a href="/api-doc/1.12.5/GraphQL/Analysis/AST/Analyzer" target="_blank" title="API docs for GraphQL::Analysis::AST::Analyzer"><code>GraphQL::Analysis::AST::Analyzer</code></a> as described in the guide, then add to your schema:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">use</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Analysis</span><span class="o">::</span><span class="no">AST</span>
</code></pre></div></div>

<p>When you use <em>both</em> <code class="language-plaintext highlighter-rouge">Interpreter</code> and <code class="language-plaintext highlighter-rouge">Analysis::AST</code>, GraphQL-Ruby will skip the slow process of building <code class="language-plaintext highlighter-rouge">irep_nodes</code>.</p>

<p>All analyzers must be migrated at once; running <em>some</em> legacy analyzers and <em>some</em> AST analyzers is not supported.</p>

<p>In GraphQL-Ruby 1.9, you can migrate to <code class="language-plaintext highlighter-rouge">Interpreter</code> before migrating to <code class="language-plaintext highlighter-rouge">Analysis::AST</code>. In that case, the <code class="language-plaintext highlighter-rouge">irep_node</code> tree will still be constructed and used for analysis, even though it will not be used for execution.</p>

<p>In GraphQL-Ruby 1.10+, <code class="language-plaintext highlighter-rouge">Interpreter</code> <em>requires</em> <code class="language-plaintext highlighter-rouge">Analysis::AST</code> and will not work without it. (Soon, these will be the default runtime modules.)</p>

<h2 id="implementation-notes">Implementation Notes</h2>

<p>Instead of a tree of <code class="language-plaintext highlighter-rouge">irep_nodes</code>, the interpreter consumes the AST directly. This removes a complicated concept from GraphQL-Ruby (<code class="language-plaintext highlighter-rouge">irep_node</code>s) and simplifies the query lifecycle. The main difference relates to how fragment spreads are resolved. In the previous runtime, the possible combinations of fields for a given object were calculated ahead of time, then some of those combinations were used during runtime, but many of them may not have been. In the new runtime, no precalculation is made; instead each object is checked against each fragment at runtime.</p>

<p>Instead of creating a <code class="language-plaintext highlighter-rouge">GraphQL::Query::Context::FieldResolutionContext</code> for <em>every</em> field in the response, the interpreter uses long-lived, mutable objects for execution bookkeeping. This is more complicated to manage, since the changes to those objects can be hard to predict, but it‚Äôs worth it for the performance gain. When needed, those bookkeeping objects can be ‚Äúforked‚Äù, so that two parts of an operation can be resolved independently.</p>

<p>Instead of calling <code class="language-plaintext highlighter-rouge">.to_graphql</code> internally to convert class-based definitions to <code class="language-plaintext highlighter-rouge">.define</code>-based definitions, the interpreter operates on class-based definitions directly. This simplifies the workflow for creating custom configurations and using them at runtime.</p>

</div>
<p class="guide-footer">
  Suggestion, improvement, or correction?
  <a href="https://github.com/rmosolgo/graphql-ruby/edit/master/guides/queries/interpreter.md">Edit this file</a> or
  <a href="https://github.com/rmosolgo/graphql-ruby/issues/new?title=Guide: Interpreter">report an issue</a>.
</p>
<script>
  // Find headers with IDs and wrap their text in `<a href=></a>`
  // That way people can easily copy the link.
  var headers = document.querySelectorAll("h1, h2, h3, h4, h5");
  var header, idText, headerLink;
  for (var i = 0; i < headers.length; i++) {
    header = headers[i];
    idText = header.id;
    if (idText) {
      headerLink = document.createElement("a");
      headerLink.href = "#" + idText;
      headerLink.textContent = header.textContent;
      header.textContent = "";
      header.appendChild(headerLink);
    }
  }
</script>

    </div>
    <script src="https://cdn.jsdelivr.net/algoliasearch/3/algoliasearchLite.min.js"></script>
    <script src="/js/search.js"></script>
  </body>
</html>
