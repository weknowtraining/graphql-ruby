<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
      <title>GraphQL - Class-based API Migration</title>
    
    <link href="https://fonts.googleapis.com/css?family=Rubik:300,400" rel="stylesheet" />
    <link rel="stylesheet" href="/css/main.css">
    <link rel="icon" href="/graphql-ruby-icon.png">
  </head>
  <body>
    <div class="header">
      <div class="header-container">
        <div class="nav">
          <a href="/" class="img-link">
            <img src="/graphql-ruby.png" alt="GraphQL Ruby Logo" />
          </a>
          <a href="/getting_started">Get Started</a>
          <a href="/guides">Guides</a>
          <a href="/api-doc/1.12.5/">API</a>
          <a href="https://tinyletter.com/graphql-ruby">Newsletter</a>
          <a href="https://github.com/rmosolgo/graphql-ruby">Source Code</a>
          <a href="https://graphql.pro">Upgrade to Pro</a>
          <input
            class="search-input"
            onkeyup="GraphQLRubySearch.run(this)"
            type="text"
            placeholder="Search the docs..."
          />
        </div>
      </div>
      <div class="search-results-container">
        <div id="search-results">
        </div>
      </div>
    </div>
    <div class="container">
      <p class="breadcrumb">
  <a href="/">GraphQL</a>
  &raquo; <a href="/guides">Guides</a>
   &raquo; <a href="/guides#schema-guides">Schema</a>
  &raquo; Class-based API Migration
</p>


<h1 class="guide-header">Class-based API Migration</h1>
<div class="guide-container">
  <p>In GraphQL <code class="language-plaintext highlighter-rouge">1.8</code>+, you can use Ruby classes to build your schema. You can <strong>mix</strong> class-style and <code class="language-plaintext highlighter-rouge">.define</code>-style type definitions in a schema.</p>

<p>The <code class="language-plaintext highlighter-rouge">.define</code> DSL is deprecated and will be removed at version 2.0.</p>

<p>You can get an overview of this new feature:</p>

<ul>
  <li><a href="#rationale--goals">Rationale &amp; Goals</a></li>
  <li><a href="#compatibility--migration-overview">Compatibility &amp; Migration Overview</a></li>
  <li><a href="#upgrader">Using the upgrader</a></li>
  <li><a href="#roadmap">Roadmap</a></li>
</ul>

<p>And learn about the APIs:</p>

<ul>
  <li><a href="/schema/definition">Schema class</a></li>
  <li><a href="#common-type-configurations">Common type configurations</a> (shared by all the following types)</li>
  <li><a href="/type_definitions/objects">Object classes</a></li>
  <li><a href="/type_definitions/interfaces">Interface classes</a></li>
  <li><a href="/type_definitions/unions">Union classes</a></li>
  <li><a href="/type_definitions/enums">Enum classes</a></li>
  <li><a href="/type_definitions/input_objects">Input Object classes</a></li>
  <li><a href="/type_definitions/scalars">Scalar classes</a></li>
  <li><a href="/type_definitions/extensions">Customizing definitions</a></li>
  <li><a href="/schema/introspection">Custom introspection</a></li>
</ul>

<h2 id="rationale--goals">Rationale &amp; Goals</h2>

<p>This new API aims to improve the “getting started” experience and the schema customization experience by replacing GraphQL-Ruby-specific DSLs with familiar Ruby semantics (classes and methods).</p>

<p>Additionally, this new API must be cross-compatible with the current schema definition API so that it can be adopted bit-by-bit.</p>

<h2 id="compatibility--migration-overview">Compatibility &amp; Migration overview</h2>

<p>Parts of your schema can be converted one-by-one, so you can convert definitions gradually.</p>

<h3 id="classes">Classes</h3>

<p>In general, each <code class="language-plaintext highlighter-rouge">.define { ... }</code> block will be converted to a class.</p>

<ul>
  <li>Instead of a <code class="language-plaintext highlighter-rouge">GraphQL::{X}Type</code>, classes inherit from <code class="language-plaintext highlighter-rouge">GraphQL::Schema::{X}</code>. For example, instead of <code class="language-plaintext highlighter-rouge">GraphQL::ObjectType.define { ... }</code>, a definition is made by extending <code class="language-plaintext highlighter-rouge">GraphQL::Schema::Object</code></li>
  <li>Any class hierarchy is supported; It’s recommended to create a base class for your application, then extend the base class for each of your types (like <code class="language-plaintext highlighter-rouge">ApplicationController</code> in Rails, see <a href="#customizing-defintions">Customizing Definitions</a>).</li>
</ul>

<p>See sections below for specific information about each schema definition class.</p>

<h3 id="️-heads-up-️">⚠️ Heads up ⚠️</h3>

<p>Keep in mind that class based Schemas will be initialized at execution time instead of application boot, depending on the size of your schema, this could result in request timeouts for your users after your application restarts. For a workaround please check https://github.com/rmosolgo/graphql-ruby/issues/2034</p>

<h3 id="type-instances">Type Instances</h3>

<p>The previous <code class="language-plaintext highlighter-rouge">GraphQL::{X}Type</code> objects are still used under the hood. Each of the new <code class="language-plaintext highlighter-rouge">GraphQL::Schema::{X}</code> classes implements a few methods:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">.to_graphql</code>: creates a new instance of <code class="language-plaintext highlighter-rouge">GraphQL::{X}Type</code></li>
  <li><code class="language-plaintext highlighter-rouge">.graphql_definition</code>: returns a cached instance of <code class="language-plaintext highlighter-rouge">GraphQL::{X}Type</code></li>
</ul>

<p>If you have custom code which breaks on new-style definitions, try calling <code class="language-plaintext highlighter-rouge">.graphql_definition</code> to get the underlying type object.</p>

<p>As described below, <code class="language-plaintext highlighter-rouge">.to_graphql</code> can be overridden to customize the type system.</p>

<h3 id="list-types-and-non-null-types">List Types and Non-Null Types</h3>

<p>Previously, list types were expressed with <code class="language-plaintext highlighter-rouge">types[T]</code> and non-null types were expressed with <code class="language-plaintext highlighter-rouge">!T</code>. Now:</p>

<ul>
  <li>List types are expressed with Ruby Arrays, <code class="language-plaintext highlighter-rouge">[T]</code>, for example, <code class="language-plaintext highlighter-rouge">field :owners, [Types::UserType]</code>
    <ul>
      <li>By default, list members are <em>non-null</em>, for example, <code class="language-plaintext highlighter-rouge">[Types::UserType]</code> becomes <code class="language-plaintext highlighter-rouge">[User!]</code></li>
      <li>If your list members may be null, add <code class="language-plaintext highlighter-rouge">, null: true</code> to the array: <code class="language-plaintext highlighter-rouge">[Types::UserType, null: true]</code> becomes <code class="language-plaintext highlighter-rouge">[User]</code> (the list may include <code class="language-plaintext highlighter-rouge">nil</code>)</li>
    </ul>
  </li>
  <li>Non-null types are expressed with keyword arguments <code class="language-plaintext highlighter-rouge">null:</code> or <code class="language-plaintext highlighter-rouge">required:</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">field</code> takes a keyword <code class="language-plaintext highlighter-rouge">null:</code>. <code class="language-plaintext highlighter-rouge">null: true</code> means the field is nullable, <code class="language-plaintext highlighter-rouge">null: false</code> means the field is non-null (equivalent to <code class="language-plaintext highlighter-rouge">!</code>)</li>
      <li><code class="language-plaintext highlighter-rouge">argument</code> takes a keyword <code class="language-plaintext highlighter-rouge">required:</code>. <code class="language-plaintext highlighter-rouge">required: true</code> means the argument is non-null (equivalent to <code class="language-plaintext highlighter-rouge">!</code>), <code class="language-plaintext highlighter-rouge">required: false</code> means that the argument is nullable</li>
    </ul>
  </li>
</ul>

<p>In legacy-style classes, you may also use plain Ruby methods to create list and non-null types:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">#to_non_null_type</code> converts a type to a non-null variant (ie, <code class="language-plaintext highlighter-rouge">T.to_non_null_type</code> is equivalent to <code class="language-plaintext highlighter-rouge">!T</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">#to_list_type</code> converts a type to a list variant (ie, <code class="language-plaintext highlighter-rouge">T.to_list_type</code> is equivalent to <code class="language-plaintext highlighter-rouge">types[T]</code>)</li>
</ul>

<p>The <code class="language-plaintext highlighter-rouge">!</code> method has been removed to avoid ambiguity with the built-in logical operator and related foot-gunning.</p>

<p>For compatibility, you may wish to backport <code class="language-plaintext highlighter-rouge">!</code> to class-based type definitions. You have two options:</p>

<p><strong>A refinement</strong>, activated in <a href="https://docs.ruby-lang.org/en/2.4.0/syntax/refinements_rdoc.html#label-Scope">file scope or class/module scope</a>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Enable `!` method in this scope</span>
<span class="n">using</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">DeprecatedDSL</span>
</code></pre></div></div>

<p><strong>A monkeypatch</strong>, activated in global scope:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Enable `!` everywhere</span>
<span class="no">GraphQL</span><span class="o">::</span><span class="no">DeprecatedDSL</span><span class="p">.</span><span class="nf">activate</span>
</code></pre></div></div>

<h3 id="connection-fields--types">Connection fields &amp; types</h3>

<p>There is no <code class="language-plaintext highlighter-rouge">connection(...)</code> method. Instead, connection fields are inferred from the type name.</p>

<p>If the type name ends in <code class="language-plaintext highlighter-rouge">Connection</code>, the field is treated as a connection field.</p>

<p>This default may be overridden by passing a <code class="language-plaintext highlighter-rouge">connection: true</code> or <code class="language-plaintext highlighter-rouge">connection: false</code> keyword.</p>

<p>For example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># This will be treated as a connection, since the type name ends in "Connection"</span>
<span class="n">field</span> <span class="ss">:projects</span><span class="p">,</span> <span class="no">Types</span><span class="o">::</span><span class="no">ProjectType</span><span class="p">.</span><span class="nf">connection_type</span>
</code></pre></div></div>

<h3 id="resolve-function-compatibility">Resolve function compatibility</h3>

<p>If you define a type with a class, you can use existing GraphQL-Ruby resolve functions with that class, for example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Using a Proc literal or #call-able</span>
<span class="n">field</span> <span class="ss">:something</span><span class="p">,</span> <span class="o">...</span> <span class="ss">resolve: </span><span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="c1"># Using a predefined field</span>
<span class="n">field</span> <span class="ss">:do_something</span><span class="p">,</span> <span class="ss">field: </span><span class="no">Mutations</span><span class="o">::</span><span class="no">DoSomething</span><span class="p">.</span><span class="nf">field</span>
<span class="c1"># Using a GraphQL::Function</span>
<span class="n">field</span> <span class="ss">:something</span><span class="p">,</span> <span class="ss">function: </span><span class="no">Functions</span><span class="o">::</span><span class="no">Something</span><span class="p">.</span><span class="nf">new</span>
</code></pre></div></div>

<p>When using these resolution implementations, they will be called with the same <code class="language-plaintext highlighter-rouge">(obj, args, ctx)</code> parameters as before.</p>

<h2 id="upgrader">Upgrader</h2>

<p><code class="language-plaintext highlighter-rouge">1.8</code> includes an <em>auto-upgrader</em> for transforming Ruby files from the <code class="language-plaintext highlighter-rouge">.define</code>-based syntax to <code class="language-plaintext highlighter-rouge">class</code>-based syntax. The upgrader is a pipeline of sequential transform operations. It ships with default pipelines, but you may customize the upgrade process by replacing the built-in pipelines with a custom ones.</p>

<p>The upgrader has an additional dependency, <code class="language-plaintext highlighter-rouge">parser</code>, which you must add to your project manually (for example, by adding to your <code class="language-plaintext highlighter-rouge">Gemfile</code>).</p>

<p>Remember that your project may be transformed one file at a time because the two syntaxes are compatible. This way, you can convert a few files and run your tests to identify outstanding issues, and continue working incrementally.</p>

<p>This transformation may not be perfect, but it should cover the most common cases. If you want to ask a question or report a bug, please <a href="https://github.com/rmosolgo/graphql-ruby/issues/new?title=Upgrader question/bug report&amp;body=Please share: the source code you're trying to transfor" target="_blank">open an issue</a>.</p>

<h3 id="using-the-default-upgrade-task">Using the Default Upgrade Task</h3>

<p>The upgrader ships with rake tasks, included as a railtie (<a href="https://github.com/rmosolgo/graphql-ruby/blob/v1.8.0/lib/graphql/railtie.rb">source</a>). The railtie will be automatically installed by your Rails app, and it provides the following tasks:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">graphql:upgrade:schema[path/to/schema.rb]</code>: upgrade the Schema file</li>
  <li><code class="language-plaintext highlighter-rouge">graphql:upgrade:member[path/to/some/type.rb]</code>: upgrade a type definition (object, interface, union, etc)</li>
  <li><code class="language-plaintext highlighter-rouge">graphql:upgrade[app/graphql/**/*]</code>: run the <code class="language-plaintext highlighter-rouge">member</code> upgrade on files which have a suffix of <code class="language-plaintext highlighter-rouge">_(type|interface|enum|union).rb</code></li>
  <li><code class="language-plaintext highlighter-rouge">graphql:upgrade:create_base_objects[path/to/graphql/]</code>: add base classes to your project</li>
</ul>

<h3 id="writing-a-custom-upgrade-task">Writing a Custom Upgrade Task</h3>

<p>You might write a custom task because:</p>

<ul>
  <li>You want to customize the transformation pipeline</li>
  <li>You’re not using Rails, so a railtie won’t work</li>
</ul>

<p>To write a custom task, you can write a rake task (or Ruby script) which uses the upgrader’s API directly.</p>

<p>Here’s the code to upgrade a type definition with the default transform pipeline:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Read the original source code into a string</span>
<span class="n">original_source</span> <span class="o">=</span> <span class="no">File</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="s2">"path/to/type.rb"</span><span class="p">)</span>
<span class="c1"># Initialize an upgrader with the default transforms</span>
<span class="n">upgrader</span> <span class="o">=</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Upgrader</span><span class="o">::</span><span class="no">Member</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">original_source</span><span class="p">)</span>
<span class="c1"># Perform the transformation, get the transformed source code</span>
<span class="n">transformed_source</span> <span class="o">=</span> <span class="n">upgrader</span><span class="p">.</span><span class="nf">upgrade</span>
<span class="c1"># Update the source file with the new code</span>
<span class="no">File</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="s2">"path/to/type.rb"</span><span class="p">,</span> <span class="n">transformed_source</span><span class="p">)</span>
</code></pre></div></div>

<p>In this custom code, you can pass some keywords to <a href="/api-doc/1.12.5/GraphQL/Upgrader/Member#new-class_method" target="_blank" title="API docs for GraphQL::Upgrader::Member.new"><code>GraphQL::Upgrader::Member.new</code></a>:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">type_transforms:</code> Applied to the source code as a whole, applied first</li>
  <li><code class="language-plaintext highlighter-rouge">field_transforms:</code> Applied to each field/connection/argument definition (extracted from the source, transformed independently, then re-inserted)</li>
  <li><code class="language-plaintext highlighter-rouge">clean_up_transforms:</code> Applied to the source code as a whole, <em>after</em> the type and field transforms</li>
</ul>

<p>Keep in mind that these transforms are performed in sequence, so the text changes over time. If you want to transform the source text, use <code class="language-plaintext highlighter-rouge">.unshift()</code> to add transforms to the <em>beginning</em> of the pipeline instead of the end.</p>

<p>For example, in <code class="language-plaintext highlighter-rouge">script/graphql-upgrade</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env ruby</span>

<span class="c1"># @example Upgrade app/graphql/types/user_type.rb:</span>
<span class="c1">#  script/graphql-upgrade app/graphql/types/user_type.rb</span>

<span class="c1"># Replace the default define-to-class transform with a custom one:</span>
<span class="n">type_transforms</span> <span class="o">=</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Upgrader</span><span class="o">::</span><span class="no">Member</span><span class="o">::</span><span class="no">DEFAULT_TYPE_TRANSFORMS</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
  <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Upgrader</span><span class="o">::</span><span class="no">TypeDefineToClassTransform</span>
    <span class="no">GraphQL</span><span class="o">::</span><span class="no">Upgrader</span><span class="o">::</span><span class="no">TypeDefineToClassTransform</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">base_class_pattern: </span><span class="s2">"Platform::</span><span class="se">\\</span><span class="s2">2s::Base"</span><span class="p">)</span>
  <span class="k">else</span>
    <span class="n">t</span>
  <span class="k">end</span>
<span class="p">}</span>

<span class="c1"># Add this transformer at the beginning of the list:</span>
<span class="n">type_transforms</span><span class="p">.</span><span class="nf">unshift</span><span class="p">(</span><span class="no">GraphQL</span><span class="o">::</span><span class="no">Upgrader</span><span class="o">::</span><span class="no">ConfigurationToKwargTransform</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">kwarg: </span><span class="s2">"visibility"</span><span class="p">))</span>

<span class="c1"># run the upgrader</span>
<span class="n">original_text</span> <span class="o">=</span> <span class="no">File</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="no">ARGV</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">upgrader</span> <span class="o">=</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Upgrader</span><span class="o">::</span><span class="no">Member</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">original_text</span><span class="p">,</span> <span class="ss">type_transforms: </span><span class="n">type_transforms</span><span class="p">)</span>
<span class="n">transformed_text</span> <span class="o">=</span> <span class="n">upgrader</span><span class="p">.</span><span class="nf">upgrade</span>
<span class="no">File</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">transformed_text</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="writing-a-custom-transformer">Writing a custom transformer</h3>

<p>Objects in the transform pipeline may be:</p>

<ul>
  <li>A class which responds to <code class="language-plaintext highlighter-rouge">.new.apply(input_text)</code> and returns the transformed code</li>
  <li>An object which responds to <code class="language-plaintext highlighter-rouge">.apply(input_text)</code> and returns the transformed code</li>
</ul>

<p>The library provides a <a href="/api-doc/1.12.5/GraphQL/Upgrader/Transform" target="_blank" title="API docs for GraphQL::Upgrader::Transform"><code>GraphQL::Upgrader::Transform</code></a> base class with a few convenience methods. You can also customize the built-in transformers listed below.</p>

<p>For example, here’s a transform which rewrites type definitions from a <code class="language-plaintext highlighter-rouge">model_type(model) do ... end</code> factory method to the class-based syntax:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Create a custom transform for our `model_type` factory:</span>
<span class="k">class</span> <span class="nc">ModelTypeToClassTransform</span> <span class="o">&lt;</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Upgrader</span><span class="o">::</span><span class="no">Transform</span>
  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="c1"># Find calls to the factory method, which have a type class inside</span>
    <span class="vi">@find_pattern</span> <span class="o">=</span> <span class="sr">/^( +)([a-zA-Z_0-9:]*) = model_type\(-&gt; ?\{ ?:{0,2}([a-zA-Z_0-9:]*) ?\} ?\) do/</span>
    <span class="c1"># Replace them with a class definition and a `model_name("...")` call:</span>
    <span class="vi">@replace_pattern</span> <span class="o">=</span> <span class="s2">"</span><span class="se">\\</span><span class="s2">1class </span><span class="se">\\</span><span class="s2">2 &lt; Platform::Objects::Base</span><span class="se">\n\\</span><span class="s2">1  model_name </span><span class="se">\"\\</span><span class="s2">3</span><span class="se">\"</span><span class="s2">"</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="n">input_text</span><span class="p">)</span>
    <span class="c1"># Run the substitution on the input text:</span>
    <span class="n">input_text</span><span class="p">.</span><span class="nf">sub</span><span class="p">(</span><span class="vi">@find_pattern</span><span class="p">,</span> <span class="vi">@replace_pattern</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="c1"># Add the class to the beginning of the pipeline</span>
<span class="n">type_transforms</span><span class="p">.</span><span class="nf">unshift</span><span class="p">(</span><span class="no">ModelTypeToClassTransform</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="built-in-transformers">Built-in transformers</h3>

<p>Follow links to the API doc to read the source of each transform:</p>

<p>Type transforms (<a href="/api-doc/1.12.5/GraphQL/Upgrader/Member/DEFAULT_TYPE_TRANSFORMS" target="_blank" title="API docs for GraphQL::Upgrader::Member::DEFAULT_TYPE_TRANSFORMS"><code>GraphQL::Upgrader::Member::DEFAULT_TYPE_TRANSFORMS</code></a>):</p>

<ul>
  <li><a href="/api-doc/1.12.5/GraphQL/Upgrader/Transform" target="_blank" title="API docs for GraphQL::Upgrader::Transform"><code>GraphQL::Upgrader::Transform</code></a> base class, provides a <code class="language-plaintext highlighter-rouge">normalize_type_expression</code> helper</li>
  <li><a href="/api-doc/1.12.5/GraphQL/Upgrader/TypeDefineToClassTransform" target="_blank" title="API docs for GraphQL::Upgrader::TypeDefineToClassTransform"><code>GraphQL::Upgrader::TypeDefineToClassTransform</code></a> turns <code class="language-plaintext highlighter-rouge">.define</code> into <code class="language-plaintext highlighter-rouge">class ...</code> with a regexp substitution</li>
  <li><a href="/api-doc/1.12.5/GraphQL/Upgrader/NameTransform" target="_blank" title="API docs for GraphQL::Upgrader::NameTransform"><code>GraphQL::Upgrader::NameTransform</code></a> takes <code class="language-plaintext highlighter-rouge">name "..."</code> and removes it if it’s redundant, or converts it to <code class="language-plaintext highlighter-rouge">graphql_name "..."</code></li>
  <li><a href="/api-doc/1.12.5/GraphQL/Upgrader/InterfacesToImplementsTransform" target="_blank" title="API docs for GraphQL::Upgrader::InterfacesToImplementsTransform"><code>GraphQL::Upgrader::InterfacesToImplementsTransform</code></a> turns <code class="language-plaintext highlighter-rouge">interfaces [A, B...]</code> into <code class="language-plaintext highlighter-rouge">implements(A)\nimplements(B)...</code></li>
</ul>

<p>Field transforms (<a href="/api-doc/1.12.5/GraphQL/Upgrader/Member/DEFAULT_FIELD_TRANSFORMS" target="_blank" title="API docs for GraphQL::Upgrader::Member::DEFAULT_FIELD_TRANSFORMS"><code>GraphQL::Upgrader::Member::DEFAULT_FIELD_TRANSFORMS</code></a>):</p>

<ul>
  <li><a href="/api-doc/1.12.5/GraphQL/Upgrader/RemoveNewlinesTransform" target="_blank" title="API docs for GraphQL::Upgrader::RemoveNewlinesTransform"><code>GraphQL::Upgrader::RemoveNewlinesTransform</code></a> removes newlines from field definitions to normalize them</li>
  <li><a href="/api-doc/1.12.5/GraphQL/Upgrader/PositionalTypeArgTransform" target="_blank" title="API docs for GraphQL::Upgrader::PositionalTypeArgTransform"><code>GraphQL::Upgrader::PositionalTypeArgTransform</code></a> moves <code class="language-plaintext highlighter-rouge">type X</code> from the <code class="language-plaintext highlighter-rouge">do ... end</code> block into a positional argument, to normalize the definition</li>
  <li><a href="/api-doc/1.12.5/GraphQL/Upgrader/ConfigurationToKwargTransform" target="_blank" title="API docs for GraphQL::Upgrader::ConfigurationToKwargTransform"><code>GraphQL::Upgrader::ConfigurationToKwargTransform</code></a> moves a <code class="language-plaintext highlighter-rouge">do ... end</code> configuration to a keyword argument. By default, this is used for <code class="language-plaintext highlighter-rouge">property</code> and <code class="language-plaintext highlighter-rouge">description</code>. You can add new instances of this transform to convert your custom DSL.</li>
  <li><a href="/api-doc/1.12.5/GraphQL/Upgrader/PropertyToMethodTransform" target="_blank" title="API docs for GraphQL::Upgrader::PropertyToMethodTransform"><code>GraphQL::Upgrader::PropertyToMethodTransform</code></a> turns <code class="language-plaintext highlighter-rouge">property:</code> to <code class="language-plaintext highlighter-rouge">method:</code></li>
  <li><a href="/api-doc/1.12.5/GraphQL/Upgrader/UnderscoreizeFieldNameTransform" target="_blank" title="API docs for GraphQL::Upgrader::UnderscoreizeFieldNameTransform"><code>GraphQL::Upgrader::UnderscoreizeFieldNameTransform</code></a> converts field names to underscore-case. <strong>NOTE</strong> that this conversion may be <em>wrong</em> in the case of <code class="language-plaintext highlighter-rouge">bodyHTML =&gt; body_html</code>. When you find it is wrong, manually revert it and preserve the camel-case field name.</li>
  <li><a href="/api-doc/1.12.5/GraphQL/Upgrader/ResolveProcToMethodTransform" target="_blank" title="API docs for GraphQL::Upgrader::ResolveProcToMethodTransform"><code>GraphQL::Upgrader::ResolveProcToMethodTransform</code></a> converts <code class="language-plaintext highlighter-rouge">resolve -&gt; { ... }</code> to <code class="language-plaintext highlighter-rouge">def {field_name} ... </code> method definitions</li>
  <li><a href="/api-doc/1.12.5/GraphQL/Upgrader/UpdateMethodSignatureTransform" target="_blank" title="API docs for GraphQL::Upgrader::UpdateMethodSignatureTransform"><code>GraphQL::Upgrader::UpdateMethodSignatureTransform</code></a> converts the type name to the new syntax, and adds <code class="language-plaintext highlighter-rouge">null:</code>/<code class="language-plaintext highlighter-rouge">required:</code> to the method signature</li>
</ul>

<p>Clean-up transforms (<a href="/api-doc/1.12.5/GraphQL/Upgrader/Member/DEFAULT_CLEAN_UP_TRANSFORMS" target="_blank" title="API docs for GraphQL::Upgrader::Member::DEFAULT_CLEAN_UP_TRANSFORMS"><code>GraphQL::Upgrader::Member::DEFAULT_CLEAN_UP_TRANSFORMS</code></a>):</p>

<ul>
  <li><a href="/api-doc/1.12.5/GraphQL/Upgrader/RemoveExcessWhitespaceTransform" target="_blank" title="API docs for GraphQL::Upgrader::RemoveExcessWhitespaceTransform"><code>GraphQL::Upgrader::RemoveExcessWhitespaceTransform</code></a> removes redundant newlines</li>
  <li><a href="/api-doc/1.12.5/GraphQL/Upgrader/RemoveEmptyBlocksTransform" target="_blank" title="API docs for GraphQL::Upgrader::RemoveEmptyBlocksTransform"><code>GraphQL::Upgrader::RemoveEmptyBlocksTransform</code></a> removes <code class="language-plaintext highlighter-rouge">do end</code> with nothing inside them</li>
</ul>

<h2 id="roadmap">Roadmap</h2>

<p>Here is a working plan for rolling out this feature:</p>

<ul>
  <li>ongoing:
    <ul>
      <li>☐ Receive feedback from GraphQL schema owners about the new API (usability &amp; goals)</li>
    </ul>
  </li>
  <li>graphql 1.8:
    <ul>
      <li>☑ Build a schema definition API based on classes instead of singletons</li>
      <li>☑ Migrate a few components of GitHub’s GraphQL schema to this new API</li>
      <li>☑ Build advanced class-based features:
        <ul>
          <li>☑ Custom <code class="language-plaintext highlighter-rouge">Context</code> classes</li>
          <li>☑ Custom introspection types</li>
          <li>☐ <del>Custom directives</del> Probably will mess with execution soon, not worth the investment now</li>
          <li>☐ <del>Custom <code class="language-plaintext highlighter-rouge">Schema#execute</code> method</del> not necessary</li>
        </ul>
      </li>
      <li>☑ Migrate all of GitHub’s GraphQL schema to this new API</li>
    </ul>
  </li>
  <li>graphql 1.9:
    <ul>
      <li>☑ Update all GraphQL-Ruby docs to reflect this new API</li>
    </ul>
  </li>
  <li>graphql 1.10:
    <ul>
      <li>☑ Begin sunsetting <code class="language-plaintext highlighter-rouge">.define</code></li>
    </ul>
  </li>
  <li>graphql 2.0:
    <ul>
      <li>☐ Remove <code class="language-plaintext highlighter-rouge">.define</code></li>
    </ul>
  </li>
</ul>

<h2 id="common-type-configurations">Common Type Configurations</h2>

<p>Some configurations are used for <em>all</em> types described below:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">graphql_name</code> overrides the type name. (The default value is the Ruby constant name, without any namespaces)</li>
  <li><code class="language-plaintext highlighter-rouge">description</code> provides a description for GraphQL introspection.</li>
</ul>

<p>For example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Types::TodoList</span> <span class="o">&lt;</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Schema</span><span class="o">::</span><span class="no">Object</span> <span class="c1"># or Scalar, Enum, Union, whatever</span>
  <span class="n">graphql_name</span> <span class="s2">"List"</span> <span class="c1"># Overrides the default of "TodoList"</span>
  <span class="n">description</span> <span class="s2">"Things to do (may have already been done)"</span>
<span class="k">end</span>
</code></pre></div></div>

<p>(Implemented in <a href="/api-doc/1.12.5/GraphQL/Schema/Member" target="_blank" title="API docs for GraphQL::Schema::Member"><code>GraphQL::Schema::Member</code></a>).</p>

</div>
<p class="guide-footer">
  Suggestion, improvement, or correction?
  <a href="https://github.com/rmosolgo/graphql-ruby/edit/master/guides/schema/class_based_api.md">Edit this file</a> or
  <a href="https://github.com/rmosolgo/graphql-ruby/issues/new?title=Guide: Class-based API Migration">report an issue</a>.
</p>
<script>
  // Find headers with IDs and wrap their text in `<a href=></a>`
  // That way people can easily copy the link.
  var headers = document.querySelectorAll("h1, h2, h3, h4, h5");
  var header, idText, headerLink;
  for (var i = 0; i < headers.length; i++) {
    header = headers[i];
    idText = header.id;
    if (idText) {
      headerLink = document.createElement("a");
      headerLink.href = "#" + idText;
      headerLink.textContent = header.textContent;
      header.textContent = "";
      header.appendChild(headerLink);
    }
  }
</script>

    </div>
    <script src="https://cdn.jsdelivr.net/algoliasearch/3/algoliasearchLite.min.js"></script>
    <script src="/js/search.js"></script>
  </body>
</html>
