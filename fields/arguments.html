<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
      <title>GraphQL - Arguments</title>
    
    <link href="https://fonts.googleapis.com/css?family=Rubik:300,400" rel="stylesheet" />
    <link rel="stylesheet" href="/css/main.css">
    <link rel="icon" href="/graphql-ruby-icon.png">
  </head>
  <body>
    <div class="header">
      <div class="header-container">
        <div class="nav">
          <a href="/" class="img-link">
            <img src="/graphql-ruby.png" alt="GraphQL Ruby Logo" />
          </a>
          <a href="/getting_started">Get Started</a>
          <a href="/guides">Guides</a>
          <a href="/api-doc/1.12.5/">API</a>
          <a href="https://tinyletter.com/graphql-ruby">Newsletter</a>
          <a href="https://github.com/rmosolgo/graphql-ruby">Source Code</a>
          <a href="https://graphql.pro">Upgrade to Pro</a>
          <input
            class="search-input"
            onkeyup="GraphQLRubySearch.run(this)"
            type="text"
            placeholder="Search the docs..."
          />
        </div>
      </div>
      <div class="search-results-container">
        <div id="search-results">
        </div>
      </div>
    </div>
    <div class="container">
      <p class="breadcrumb">
  <a href="/">GraphQL</a>
  &raquo; <a href="/guides">Guides</a>
   &raquo; <a href="/guides#fields-guides">Fields</a>
  &raquo; Arguments
</p>


<h1 class="guide-header">Arguments</h1>
<div class="guide-container">
  <p>Fields can take <strong>arguments</strong> as input. These can be used to determine the return value (eg, filtering search results) or to modify the application state (eg, updating the database in <code class="language-plaintext highlighter-rouge">MutationType</code>).</p>

<p>Arguments are defined with the <code class="language-plaintext highlighter-rouge">argument</code> helper. These arguments are passed as <a href="https://robots.thoughtbot.com/ruby-2-keyword-arguments">keyword arguments</a> to the resolver method:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">field</span> <span class="ss">:search_posts</span><span class="p">,</span> <span class="p">[</span><span class="no">PostType</span><span class="p">],</span> <span class="ss">null: </span><span class="kp">false</span> <span class="k">do</span>
  <span class="n">argument</span> <span class="ss">:category</span><span class="p">,</span> <span class="no">String</span><span class="p">,</span> <span class="ss">required: </span><span class="kp">true</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">search_posts</span><span class="p">(</span><span class="n">category</span><span class="p">:)</span>
  <span class="no">Post</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">category: </span><span class="n">category</span><span class="p">).</span><span class="nf">limit</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>To make an argument optional, set <code class="language-plaintext highlighter-rouge">required: false</code>, and set default values for the corresponding keyword arguments:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">field</span> <span class="ss">:search_posts</span><span class="p">,</span> <span class="p">[</span><span class="no">PostType</span><span class="p">],</span> <span class="ss">null: </span><span class="kp">false</span> <span class="k">do</span>
  <span class="n">argument</span> <span class="ss">:category</span><span class="p">,</span> <span class="no">String</span><span class="p">,</span> <span class="ss">required: </span><span class="kp">false</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">search_posts</span><span class="p">(</span><span class="ss">category: </span><span class="kp">nil</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">category</span>
    <span class="no">Post</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">category: </span><span class="n">category</span><span class="p">).</span><span class="nf">limit</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
  <span class="k">else</span>
    <span class="no">Post</span><span class="p">.</span><span class="nf">all</span><span class="p">.</span><span class="nf">limit</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Be aware that if all arguments are optional and the query does not provide any arguments, then the resolver method will be called with no arguments. To prevent an <code class="language-plaintext highlighter-rouge">ArgumentError</code> in this case, you must either specify default values for all keyword arguments (as done in the prior example) or use the double splat operator argument in the method definition. For example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">search_posts</span><span class="p">(</span><span class="o">**</span><span class="n">args</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">args</span><span class="p">[</span><span class="ss">:category</span><span class="p">]</span>
    <span class="no">Post</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">category: </span><span class="n">args</span><span class="p">[</span><span class="ss">:category</span><span class="p">]).</span><span class="nf">limit</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
  <span class="k">else</span>
    <span class="no">Post</span><span class="p">.</span><span class="nf">all</span><span class="p">.</span><span class="nf">limit</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Another approach is to use <code class="language-plaintext highlighter-rouge">default_value: value</code> to provide a default value for the argument if it is not supplied in the query.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">field</span> <span class="ss">:search_posts</span><span class="p">,</span> <span class="p">[</span><span class="no">PostType</span><span class="p">],</span> <span class="ss">null: </span><span class="kp">false</span> <span class="k">do</span>
  <span class="n">argument</span> <span class="ss">:category</span><span class="p">,</span> <span class="no">String</span><span class="p">,</span> <span class="ss">required: </span><span class="kp">false</span><span class="p">,</span> <span class="ss">default_value: </span><span class="s2">"Programming"</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">search_posts</span><span class="p">(</span><span class="n">category</span><span class="p">:)</span>
  <span class="no">Post</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">category: </span><span class="n">category</span><span class="p">).</span><span class="nf">limit</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p><strong>Experimental:</strong> <strong>Deprecated</strong> arguments can be marked by adding a <code class="language-plaintext highlighter-rouge">deprecation_reason:</code> keyword argument:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">field</span> <span class="ss">:search_posts</span><span class="p">,</span> <span class="p">[</span><span class="no">PostType</span><span class="p">],</span> <span class="ss">null: </span><span class="kp">false</span> <span class="k">do</span>
  <span class="n">argument</span> <span class="ss">:name</span><span class="p">,</span> <span class="no">String</span><span class="p">,</span> <span class="ss">required: </span><span class="kp">false</span><span class="p">,</span> <span class="ss">deprecation_reason: </span><span class="s2">"Use `query` instead."</span>
  <span class="n">argument</span> <span class="ss">:query</span><span class="p">,</span> <span class="no">String</span><span class="p">,</span> <span class="ss">required: </span><span class="kp">false</span>
<span class="k">end</span>
</code></pre></div></div>
<p>Note argument deprecation is a stage 2 GraphQL <a href="https://github.com/graphql/graphql-spec/pull/525">proposal</a> so not all clients will leverage this information.</p>

<p>Use <code class="language-plaintext highlighter-rouge">as: :alternate_name</code> to use a different key from within your resolvers while
exposing another key to clients.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">field</span> <span class="ss">:post</span><span class="p">,</span> <span class="no">PostType</span><span class="p">,</span> <span class="ss">null: </span><span class="kp">false</span> <span class="k">do</span>
  <span class="n">argument</span> <span class="ss">:post_id</span><span class="p">,</span> <span class="no">ID</span><span class="p">,</span> <span class="ss">required: </span><span class="kp">true</span><span class="p">,</span> <span class="ss">as: :id</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">post</span><span class="p">(</span><span class="nb">id</span><span class="p">:)</span>
  <span class="no">Post</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Provide a <code class="language-plaintext highlighter-rouge">prepare</code> function to modify or validate the value of an argument before the field’s resolver method is executed:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">field</span> <span class="ss">:posts</span><span class="p">,</span> <span class="p">[</span><span class="no">PostType</span><span class="p">],</span> <span class="ss">null: </span><span class="kp">false</span> <span class="k">do</span>
  <span class="n">argument</span> <span class="ss">:start_date</span><span class="p">,</span> <span class="no">String</span><span class="p">,</span> <span class="ss">required: </span><span class="kp">true</span><span class="p">,</span> <span class="ss">prepare: </span><span class="o">-&gt;</span><span class="p">(</span><span class="n">startDate</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1"># return the prepared argument.</span>
    <span class="c1"># raise a GraphQL::ExecutionError to halt the execution of the field and</span>
    <span class="c1"># add the exception's message to the `errors` key.</span>
  <span class="p">}</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">posts</span><span class="p">(</span><span class="n">start_date</span><span class="p">:)</span>
  <span class="c1"># use prepared start_date</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Arguments that are snake_cased will be camelized in the GraphQL schema. Using the example of:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">field</span> <span class="ss">:posts</span><span class="p">,</span> <span class="p">[</span><span class="no">PostType</span><span class="p">],</span> <span class="ss">null: </span><span class="kp">false</span> <span class="k">do</span>
  <span class="n">argument</span> <span class="ss">:start_year</span><span class="p">,</span> <span class="no">Int</span><span class="p">,</span> <span class="ss">required: </span><span class="kp">true</span>
<span class="k">end</span>
</code></pre></div></div>

<p>The corresponding GraphQL query will look like:</p>

<div class="language-graphql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="n">posts</span><span class="p">(</span><span class="n">startYear</span><span class="p">:</span><span class="w"> </span><span class="mi">2018</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="n">id</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>To disable auto-camelization, pass <code class="language-plaintext highlighter-rouge">camelize: false</code> to the <code class="language-plaintext highlighter-rouge">argument</code> method.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">field</span> <span class="ss">:posts</span><span class="p">,</span> <span class="p">[</span><span class="no">PostType</span><span class="p">],</span> <span class="ss">null: </span><span class="kp">false</span> <span class="k">do</span>
  <span class="n">argument</span> <span class="ss">:start_year</span><span class="p">,</span> <span class="no">Int</span><span class="p">,</span> <span class="ss">required: </span><span class="kp">true</span><span class="p">,</span> <span class="ss">camelize: </span><span class="kp">false</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Furthermore, if your argument is already camelCased, then it will remain camelized in the GraphQL schema. However, the argument will be converted to snake_case when it is passed to the resolver method:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">field</span> <span class="ss">:posts</span><span class="p">,</span> <span class="p">[</span><span class="no">PostType</span><span class="p">],</span> <span class="ss">null: </span><span class="kp">false</span> <span class="k">do</span>
  <span class="n">argument</span> <span class="ss">:startYear</span><span class="p">,</span> <span class="no">Int</span><span class="p">,</span> <span class="ss">required: </span><span class="kp">true</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">posts</span><span class="p">(</span><span class="n">start_year</span><span class="p">:)</span>
  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Only certain types are valid for arguments:</p>

<ul>
  <li><a href="/api-doc/1.12.5/GraphQL/ScalarType" target="_blank" title="API docs for GraphQL::ScalarType"><code>GraphQL::ScalarType</code></a>, including built-in scalars (string, int, float, boolean, ID)</li>
  <li><a href="/api-doc/1.12.5/GraphQL/EnumType" target="_blank" title="API docs for GraphQL::EnumType"><code>GraphQL::EnumType</code></a></li>
  <li><a href="/api-doc/1.12.5/GraphQL/InputObjectType" target="_blank" title="API docs for GraphQL::InputObjectType"><code>GraphQL::InputObjectType</code></a>, which allows key-value pairs as input</li>
  <li><a href="/api-doc/1.12.5/GraphQL/ListType" target="_blank" title="API docs for GraphQL::ListType"><code>GraphQL::ListType</code></a>s of a valid input type</li>
  <li><a href="/api-doc/1.12.5/GraphQL/NonNullType" target="_blank" title="API docs for GraphQL::NonNullType"><code>GraphQL::NonNullType</code></a>s of a valid input type</li>
</ul>

</div>
<p class="guide-footer">
  Suggestion, improvement, or correction?
  <a href="https://github.com/rmosolgo/graphql-ruby/edit/master/guides/fields/arguments.md">Edit this file</a> or
  <a href="https://github.com/rmosolgo/graphql-ruby/issues/new?title=Guide: Arguments">report an issue</a>.
</p>
<script>
  // Find headers with IDs and wrap their text in `<a href=></a>`
  // That way people can easily copy the link.
  var headers = document.querySelectorAll("h1, h2, h3, h4, h5");
  var header, idText, headerLink;
  for (var i = 0; i < headers.length; i++) {
    header = headers[i];
    idText = header.id;
    if (idText) {
      headerLink = document.createElement("a");
      headerLink.href = "#" + idText;
      headerLink.textContent = header.textContent;
      header.textContent = "";
      header.appendChild(headerLink);
    }
  }
</script>

    </div>
    <script src="https://cdn.jsdelivr.net/algoliasearch/3/algoliasearchLite.min.js"></script>
    <script src="/js/search.js"></script>
  </body>
</html>
